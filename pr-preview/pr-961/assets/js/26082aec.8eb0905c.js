"use strict";(globalThis.webpackChunkunderthesea_docs=globalThis.webpackChunkunderthesea_docs||[]).push([[3388],{9432(e,n,i){i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>o});var t=i(2413),r=i(4848),s=i(8453);const l={slug:"rewrite-rust-crf-model",title:"Rewriting CRF Model in Rust",authors:["rain1024"],tags:["rust","performance","crf","nlp"]},d="Rewriting CRF Model in Rust: A 20% Performance Boost",a={authorsImageUrls:[void 0]},o=[{value:"Background",id:"background",level:2},{value:"The Architecture Change",id:"the-architecture-change",level:2},{value:"Before (v9.2.1)",id:"before-v921",level:3},{value:"After (v9.2.5)",id:"after-v925",level:3},{value:"Code Changes",id:"code-changes",level:2},{value:"Inference Benchmark Results",id:"inference-benchmark-results",level:2},{value:"Why Is Inference Faster?",id:"why-is-inference-faster",level:2},{value:"1. Unified Runtime",id:"1-unified-runtime",level:3},{value:"2. Optimized Viterbi Implementation",id:"2-optimized-viterbi-implementation",level:3},{value:"3. Zero-Copy Where Possible",id:"3-zero-copy-where-possible",level:3},{value:"4. Removed Dependency",id:"4-removed-dependency",level:3},{value:"Training Optimizations",id:"training-optimizations",level:2},{value:"CRF Training Algorithm",id:"crf-training-algorithm",level:3},{value:"Starting Point",id:"starting-point",level:3},{value:"Optimization 1: Flat Data Structure for Feature Lookup",id:"optimization-1-flat-data-structure-for-feature-lookup",level:3},{value:"Optimization 2: Loop Unrolling for Auto-Vectorization",id:"optimization-2-loop-unrolling-for-auto-vectorization",level:3},{value:"Optimization 3: Unsafe Bounds-Check Elimination",id:"optimization-3-unsafe-bounds-check-elimination",level:3},{value:"Optimization 4: Fused Operations",id:"optimization-4-fused-operations",level:3},{value:"Cumulative Optimization Impact",id:"cumulative-optimization-impact",level:3},{value:"Training Benchmark Results (200 iterations)",id:"training-benchmark-results-200-iterations",level:3},{value:"Accuracy Verification",id:"accuracy-verification",level:3},{value:"What Didn&#39;t Work",id:"what-didnt-work",level:2},{value:"Key Insight: Different Tasks, Different Bottlenecks",id:"key-insight-different-tasks-different-bottlenecks",level:2},{value:"Why python-crfsuite Was Initially Faster",id:"why-python-crfsuite-was-initially-faster",level:3},{value:"Lessons Learned",id:"lessons-learned",level:3},{value:"Migration Path",id:"migration-path",level:2},{value:"Model Compatibility",id:"model-compatibility",level:2},{value:"Conclusion",id:"conclusion",level:2},{value:"Try It Out",id:"try-it-out",level:2}];function c(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["In underthesea v9.2.5, we completed the migration from ",(0,r.jsx)(n.code,{children:"python-crfsuite"})," to our native Rust implementation ",(0,r.jsx)(n.code,{children:"underthesea-core"}),". This change resulted in a ",(0,r.jsx)(n.strong,{children:"20% performance improvement"})," across all CRF-based NLP tasks, plus up to ",(0,r.jsx)(n.strong,{children:"10x faster training"})," through systematic optimization."]}),"\n",(0,r.jsx)(n.h2,{id:"background",children:"Background"}),"\n",(0,r.jsx)(n.p,{children:"Underthesea uses Conditional Random Fields (CRF) for several core NLP tasks:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Word tokenization"}),"\n",(0,r.jsx)(n.li,{children:"POS tagging"}),"\n",(0,r.jsx)(n.li,{children:"Named Entity Recognition (NER)"}),"\n",(0,r.jsx)(n.li,{children:"Chunking"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Previously, we relied on ",(0,r.jsx)(n.code,{children:"python-crfsuite"}),", a Python wrapper for the CRFsuite C++ library. While functional, this introduced overhead from multiple language boundaries."]}),"\n",(0,r.jsx)(n.h2,{id:"the-architecture-change",children:"The Architecture Change"}),"\n",(0,r.jsx)(n.h3,{id:"before-v921",children:"Before (v9.2.1)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        Python                                \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502    Input     \u2502\u2500\u2500\u2500\u25b6\u2502 CRFFeaturizer\u2502\u2500\u2500\u2500\u25b6\u2502   Python     \u2502  \u2502\n\u2502  \u2502   Tokens     \u2502    \u2502    (Rust)    \u2502    \u2502    List      \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                                                  \u2502          \u2502\n\u2502                                                  \u25bc          \u2502\n\u2502                                          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502                                          \u2502  pycrfsuite  \u2502  \u2502\n\u2502                                          \u2502    (C++)     \u2502  \u2502\n\u2502                                          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,r.jsx)(n.p,{children:"The data flow crossed multiple language boundaries:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Python \u2192 Rust (CRFFeaturizer)"}),"\n",(0,r.jsx)(n.li,{children:"Rust \u2192 Python (feature list)"}),"\n",(0,r.jsx)(n.li,{children:"Python \u2192 C++ (pycrfsuite)"}),"\n",(0,r.jsx)(n.li,{children:"C++ \u2192 Python (tags)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"after-v925",children:"After (v9.2.5)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        Python                                \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502    Input     \u2502\u2500\u2500\u2500\u25b6\u2502 CRFFeaturizer\u2502\u2500\u2500\u2500\u25b6\u2502  CRFTagger   \u2502  \u2502\n\u2502  \u2502   Tokens     \u2502    \u2502    (Rust)    \u2502    \u2502    (Rust)    \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                              \u2502                   \u2502          \u2502\n\u2502                              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2502\n\u2502                               underthesea-core              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,r.jsx)(n.p,{children:"Now both preprocessing and inference are in Rust within the same module, eliminating the C++ dependency entirely."}),"\n",(0,r.jsx)(n.h2,{id:"code-changes",children:"Code Changes"}),"\n",(0,r.jsx)(n.p,{children:"The change was minimal from the API perspective:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Before:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import pycrfsuite\nfrom underthesea_core import CRFFeaturizer\n\nclass FastCRFSequenceTagger:\n    def load(self, base_path):\n        estimator = pycrfsuite.Tagger()\n        estimator.open(model_path)\n        # ...\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"After:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from underthesea_core import CRFFeaturizer, CRFTagger\n\nclass FastCRFSequenceTagger:\n    def load(self, base_path):\n        estimator = CRFTagger()\n        estimator.load(model_path)\n        # ...\n"})}),"\n",(0,r.jsx)(n.h2,{id:"inference-benchmark-results",children:"Inference Benchmark Results"}),"\n",(0,r.jsx)(n.p,{children:"We benchmarked both versions on the same hardware with 100 iterations:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Function"}),(0,r.jsx)(n.th,{children:"v9.2.1 (pycrfsuite)"}),(0,r.jsx)(n.th,{children:"v9.2.5 (Rust)"}),(0,r.jsx)(n.th,{children:"Improvement"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"word_tokenize"}),(0,r.jsx)(n.td,{children:"1.45ms"}),(0,r.jsx)(n.td,{children:"1.18ms"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"-19%"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"pos_tag"}),(0,r.jsx)(n.td,{children:"3.58ms"}),(0,r.jsx)(n.td,{children:"2.93ms"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"-18%"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"ner"}),(0,r.jsx)(n.td,{children:"9.61ms"}),(0,r.jsx)(n.td,{children:"8.49ms"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"-12%"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"chunk"}),(0,r.jsx)(n.td,{children:"6.19ms"}),(0,r.jsx)(n.td,{children:"5.65ms"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"-9%"})})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"why-is-inference-faster",children:"Why Is Inference Faster?"}),"\n",(0,r.jsx)(n.h3,{id:"1-unified-runtime",children:"1. Unified Runtime"}),"\n",(0,r.jsxs)(n.p,{children:["Both ",(0,r.jsx)(n.code,{children:"CRFFeaturizer"})," and ",(0,r.jsx)(n.code,{children:"CRFTagger"})," are now in the same Rust module. This allows:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Shared memory management"}),"\n",(0,r.jsx)(n.li,{children:"No intermediate Python object creation"}),"\n",(0,r.jsx)(n.li,{children:"Potential for future optimizations (e.g., fusing operations)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"2-optimized-viterbi-implementation",children:"2. Optimized Viterbi Implementation"}),"\n",(0,r.jsx)(n.p,{children:"Our Rust implementation uses pre-allocated vectors and cache-friendly memory layouts:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"fn viterbi(&self, attr_ids: &[Vec<u32>]) -> TaggingResult {\n    let n = attr_ids.len();\n    let num_labels = self.model.num_labels;\n\n    // Pre-allocated score matrix\n    let mut score = vec![vec![f64::NEG_INFINITY; num_labels]; n];\n    let mut back = vec![vec![0u32; num_labels]; n];\n\n    // Cache emission scores per position\n    let emission_t = self.model.emission_scores(&attr_ids[t]);\n\n    // Direct memory access in inner loop\n    for y in 0..num_labels {\n        for y_prev in 0..num_labels {\n            let trans = self.model.get_transition(y_prev as u32, y as u32);\n            // ...\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-zero-copy-where-possible",children:"3. Zero-Copy Where Possible"}),"\n",(0,r.jsx)(n.p,{children:"PyO3 bindings allow efficient data transfer between Python and Rust without unnecessary copying."}),"\n",(0,r.jsx)(n.h3,{id:"4-removed-dependency",children:"4. Removed Dependency"}),"\n",(0,r.jsxs)(n.p,{children:["Removing ",(0,r.jsx)(n.code,{children:"python-crfsuite"})," also means:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Simpler installation (no C++ compiler needed)"}),"\n",(0,r.jsx)(n.li,{children:"Smaller package size"}),"\n",(0,r.jsx)(n.li,{children:"Fewer potential compatibility issues"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"training-optimizations",children:"Training Optimizations"}),"\n",(0,r.jsxs)(n.p,{children:["Beyond inference, we also optimized the CRF trainer in ",(0,r.jsx)(n.code,{children:"underthesea-core"}),". The original Rust trainer was ",(0,r.jsx)(n.strong,{children:"7.2x slower"})," than python-crfsuite for word segmentation. Through four key optimizations, we made it competitive \u2014 and even faster for some tasks."]}),"\n",(0,r.jsx)(n.h3,{id:"crf-training-algorithm",children:"CRF Training Algorithm"}),"\n",(0,r.jsxs)(n.p,{children:["The trainer uses L-BFGS optimization with OWL-QN extension for L1 regularization. The core computation is the forward-backward algorithm with complexity ",(0,r.jsx)(n.strong,{children:"O(n \xd7 L\xb2)"})," per sequence, where n is the sequence length and L is the number of labels."]}),"\n",(0,r.jsxs)(n.p,{children:["Following CRFsuite's approach, we use ",(0,r.jsx)(n.strong,{children:"scaled probability space"})," instead of log-space \u2014 avoiding log/exp in inner loops while maintaining numerical stability with scaling factors."]}),"\n",(0,r.jsx)(n.h3,{id:"starting-point",children:"Starting Point"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Task"}),(0,r.jsx)(n.th,{children:"python-crfsuite"}),(0,r.jsx)(n.th,{children:"underthesea-core (original)"}),(0,r.jsx)(n.th,{children:"Slowdown"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Word Segmentation"}),(0,r.jsx)(n.td,{children:"2m 34s"}),(0,r.jsx)(n.td,{children:"18m 33s"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"7.2x slower"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"POS Tagging"}),(0,r.jsx)(n.td,{children:"4m 50s"}),(0,r.jsx)(n.td,{children:"7m 21s"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"1.5x slower"})})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"optimization-1-flat-data-structure-for-feature-lookup",children:"Optimization 1: Flat Data Structure for Feature Lookup"}),"\n",(0,r.jsxs)(n.p,{children:["The original used nested vectors (",(0,r.jsx)(n.code,{children:"Vec<Vec<(u32, u32)>>"}),") for feature lookup \u2014 each inner ",(0,r.jsx)(n.code,{children:"Vec"})," separately heap-allocated, causing cache misses for large feature sets (562k features)."]}),"\n",(0,r.jsx)(n.p,{children:"We flattened into contiguous arrays with offset indexing:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"// Contiguous memory, excellent cache locality\nattr_offsets: Vec<u32>               // attr_id -> start index\nattr_features_flat: Vec<(u32, u32)>  // flattened (label_id, feature_id) pairs\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Result"}),": Word segmentation went from 18m 33s to 1m 49s \u2014 a ",(0,r.jsx)(n.strong,{children:"10.2x speedup"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"optimization-2-loop-unrolling-for-auto-vectorization",children:"Optimization 2: Loop Unrolling for Auto-Vectorization"}),"\n",(0,r.jsx)(n.p,{children:"The forward-backward algorithm has O(n \xd7 L\xb2) inner loops. For POS tagging (16 labels = 256 transitions per timestep), we applied 4-way manual loop unrolling to enable SIMD auto-vectorization."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Result"}),": POS tagging (10 iterations) went from 25.7s to 17.58s \u2014 a ",(0,r.jsx)(n.strong,{children:"1.46x speedup"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"optimization-3-unsafe-bounds-check-elimination",children:"Optimization 3: Unsafe Bounds-Check Elimination"}),"\n",(0,r.jsxs)(n.p,{children:["We used ",(0,r.jsx)(n.code,{children:"unsafe"})," with ",(0,r.jsx)(n.code,{children:"get_unchecked"})," for hot paths where indices are provably valid, eliminating Rust's bounds checks in tight loops. All ",(0,r.jsx)(n.code,{children:"unsafe"})," blocks are guarded by loop bounds derived from array lengths and algorithm invariants."]}),"\n",(0,r.jsx)(n.h3,{id:"optimization-4-fused-operations",children:"Optimization 4: Fused Operations"}),"\n",(0,r.jsx)(n.p,{children:"Separate loops for related operations (scale, sum, normalize) were fused into single passes to reduce redundant memory traversals."}),"\n",(0,r.jsx)(n.h3,{id:"cumulative-optimization-impact",children:"Cumulative Optimization Impact"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Optimization"}),(0,r.jsx)(n.th,{children:"Word Seg Speedup"}),(0,r.jsx)(n.th,{children:"POS Tag Speedup"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Baseline (original)"}),(0,r.jsx)(n.td,{children:"1.0x"}),(0,r.jsx)(n.td,{children:"1.0x"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"+ Flat data structure"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"10.2x"})}),(0,r.jsx)(n.td,{children:"1.4x"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"+ Loop unrolling"}),(0,r.jsx)(n.td,{children:"10.2x"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"2.1x"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"+ Unsafe bounds elim"}),(0,r.jsx)(n.td,{children:"~10.2x"}),(0,r.jsx)(n.td,{children:"~2.3x"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Total"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"10.2x"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"2.3x"})})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"training-benchmark-results-200-iterations",children:"Training Benchmark Results (200 iterations)"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Task"}),(0,r.jsx)(n.th,{children:"Features"}),(0,r.jsx)(n.th,{children:"Labels"}),(0,r.jsx)(n.th,{children:"python-crfsuite"}),(0,r.jsx)(n.th,{children:"underthesea-core"}),(0,r.jsx)(n.th,{children:"Result"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Word Segmentation"}),(0,r.jsx)(n.td,{children:"562,885"}),(0,r.jsx)(n.td,{children:"2"}),(0,r.jsx)(n.td,{children:"2m 2s"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"1m 38s"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"1.24x faster"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"POS Tagging"}),(0,r.jsx)(n.td,{children:"626,723"}),(0,r.jsx)(n.td,{children:"16"}),(0,r.jsx)(n.td,{children:"4m 3s"}),(0,r.jsx)(n.td,{children:"4m 14s"}),(0,r.jsx)(n.td,{children:"~equal (4% slower)"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"accuracy-verification",children:"Accuracy Verification"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Task"}),(0,r.jsx)(n.th,{children:"Metric"}),(0,r.jsx)(n.th,{children:"python-crfsuite"}),(0,r.jsx)(n.th,{children:"underthesea-core"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Word Segmentation"}),(0,r.jsx)(n.td,{children:"Syllable Accuracy"}),(0,r.jsx)(n.td,{children:"98.89%"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"98.89%"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Word Segmentation"}),(0,r.jsx)(n.td,{children:"Word F1"}),(0,r.jsx)(n.td,{children:"98.00%"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"98.00%"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"POS Tagging"}),(0,r.jsx)(n.td,{children:"Accuracy"}),(0,r.jsx)(n.td,{children:"95.98%"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"95.97%"})})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Accuracy is identical"})," \u2014 optimizations only affected performance, not correctness."]}),"\n",(0,r.jsx)(n.h2,{id:"what-didnt-work",children:"What Didn't Work"}),"\n",(0,r.jsx)(n.p,{children:"We also evaluated several optimizations that did not provide significant improvements:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Explicit SIMD Intrinsics (AVX2)"}),": The inner loops process only 2-16 labels, too small for explicit SIMD to outperform the compiler's auto-vectorization with loop unrolling."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Parallel Forward-Backward (Rayon)"}),": Thread-local gradient accumulation overhead from buffer allocation per sequence and gradient merging negated the parallelism benefits."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Compressed Sparse Features"}),": The flat data structure with offset indexing already provides efficient sparse feature access \u2014 additional compression just adds decode overhead."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"key-insight-different-tasks-different-bottlenecks",children:"Key Insight: Different Tasks, Different Bottlenecks"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Feature Set Size"}),(0,r.jsx)(n.th,{children:"Bottleneck"}),(0,r.jsx)(n.th,{children:"Best Optimization"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Large (500k+)"}),(0,r.jsx)(n.td,{children:"Feature lookup (cache misses)"}),(0,r.jsx)(n.td,{children:"Flat data structure"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Small (<50k)"}),(0,r.jsx)(n.td,{children:"Forward-backward O(L\xb2)"}),(0,r.jsx)(n.td,{children:"Loop unrolling"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"why-python-crfsuite-was-initially-faster",children:"Why python-crfsuite Was Initially Faster"}),"\n",(0,r.jsx)(n.p,{children:"CRFsuite (C implementation) already had hand-optimized sparse feature storage, SIMD-vectorized matrix operations (AVX/SSE intrinsics), cache-optimized memory layouts, and decades of optimization. Our flat data structure and loop unrolling effectively replicated these advantages in Rust."}),"\n",(0,r.jsx)(n.h3,{id:"lessons-learned",children:"Lessons Learned"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Profile first"})," \u2014 the bottleneck was different for each task"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Data structure matters"})," \u2014 flat arrays beat nested vectors by 10x"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cache locality is critical"})," \u2014 sequential memory access enables hardware prefetching"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Unsafe Rust is justified"})," \u2014 when correctness is provable and performance is critical"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Incremental migration reduces risk"})," \u2014 migrating one task at a time allowed validation at each step"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"migration-path",children:"Migration Path"}),"\n",(0,r.jsx)(n.p,{children:"The migration was done incrementally across 4 releases:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Version"}),(0,r.jsx)(n.th,{children:"Changes"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"v9.2.2"}),(0,r.jsx)(n.td,{children:"word_tokenize migrated"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"v9.2.3"}),(0,r.jsx)(n.td,{children:"pos_tag, ner, chunking migrated"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"v9.2.4"}),(0,r.jsx)(n.td,{children:"CRFTrainer migrated, removed unused files"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"v9.2.5"}),(0,r.jsx)(n.td,{children:"Removed python-crfsuite dependency"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"model-compatibility",children:"Model Compatibility"}),"\n",(0,r.jsxs)(n.p,{children:["The Rust implementation can load existing ",(0,r.jsx)(n.code,{children:".crfsuite"})," model files trained by python-crfsuite. No retraining is required."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Works with both old and new models\nfrom underthesea import word_tokenize\nword_tokenize(\"H\xe0 N\u1ed9i l\xe0 th\u1ee7 \u0111\xf4 c\u1ee7a Vi\u1ec7t Nam\")\n# ['H\xe0 N\u1ed9i', 'l\xe0', 'th\u1ee7 \u0111\xf4', 'c\u1ee7a', 'Vi\u1ec7t Nam']\n"})}),"\n",(0,r.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsx)(n.p,{children:"By rewriting our CRF implementation in Rust and unifying the pipeline, we achieved:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"12-19% faster inference"})," across all CRF-based tasks"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"1.24x faster training"})," for word segmentation (10x from original Rust implementation)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Identical accuracy"})," \u2014 no degradation from the migration"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Simpler dependency tree"})," (no python-crfsuite / C++ compiler needed)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Better maintainability"})," with a single Rust codebase"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The full implementation is available in ",(0,r.jsx)(n.a,{href:"https://github.com/undertheseanlp/underthesea/tree/main/extensions/underthesea_core",children:"underthesea-core"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"try-it-out",children:"Try It Out"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"pip install underthesea==9.2.5\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from underthesea import word_tokenize, pos_tag, ner, chunk\n\nword_tokenize("Vi\u1ec7t Nam")  # 20% faster!\n'})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453(e,n,i){i.d(n,{R:()=>l,x:()=>d});var t=i(6540);const r={},s=t.createContext(r);function l(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),t.createElement(s.Provider,{value:n},e.children)}},2413(e){e.exports=JSON.parse('{"permalink":"/blog/rewrite-rust-crf-model","editUrl":"https://github.com/undertheseanlp/underthesea/tree/main/docusaurus/blog/2026-02-02-rewrite-rust-crf-model.md","source":"@site/blog/2026-02-02-rewrite-rust-crf-model.md","title":"Rewriting CRF Model in Rust","description":"In underthesea v9.2.5, we completed the migration from python-crfsuite to our native Rust implementation underthesea-core. This change resulted in a 20% performance improvement across all CRF-based NLP tasks, plus up to 10x faster training through systematic optimization.","date":"2026-02-02T00:00:00.000Z","tags":[{"inline":true,"label":"rust","permalink":"/blog/tags/rust"},{"inline":true,"label":"performance","permalink":"/blog/tags/performance"},{"inline":true,"label":"crf","permalink":"/blog/tags/crf"},{"inline":true,"label":"nlp","permalink":"/blog/tags/nlp"}],"readingTime":6.04,"hasTruncateMarker":true,"authors":[{"name":"Vu Anh","title":"Creator of Underthesea","url":"https://github.com/rain1024","imageURL":"https://github.com/rain1024.png","key":"rain1024","page":null}],"frontMatter":{"slug":"rewrite-rust-crf-model","title":"Rewriting CRF Model in Rust","authors":["rain1024"],"tags":["rust","performance","crf","nlp"]},"unlisted":false,"prevItem":{"title":"Rust-Powered Text Classification","permalink":"/blog/rust-text-classifier"}}')}}]);