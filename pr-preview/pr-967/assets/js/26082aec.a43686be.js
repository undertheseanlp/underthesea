"use strict";(globalThis.webpackChunkunderthesea_docs=globalThis.webpackChunkunderthesea_docs||[]).push([[3388],{9432(e,n,r){r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>o,frontMatter:()=>l,metadata:()=>i,toc:()=>c});var i=r(2413),t=r(4848),s=r(8453);const l={slug:"rewrite-rust-crf-model",title:"Rewriting CRF Model in Rust",authors:["rain1024"],tags:["rust","performance","crf","nlp"]},d="Rewriting CRF Model in Rust: A 20% Performance Boost",a={authorsImageUrls:[void 0]},c=[{value:"Background",id:"background",level:2},{value:"The Architecture Change",id:"the-architecture-change",level:2},{value:"Before (v9.2.1)",id:"before-v921",level:3},{value:"After (v9.2.5)",id:"after-v925",level:3},{value:"Code Changes",id:"code-changes",level:2},{value:"Inference Benchmark Results",id:"inference-benchmark-results",level:2},{value:"Why Is Inference Faster?",id:"why-is-inference-faster",level:2},{value:"1. Unified Runtime",id:"1-unified-runtime",level:3},{value:"2. Optimized Viterbi Implementation",id:"2-optimized-viterbi-implementation",level:3},{value:"3. Zero-Copy Where Possible",id:"3-zero-copy-where-possible",level:3},{value:"4. Removed Dependency",id:"4-removed-dependency",level:3},{value:"Training Optimizations",id:"training-optimizations",level:2},{value:"CRF Training Algorithm",id:"crf-training-algorithm",level:3},{value:"Starting Point",id:"starting-point",level:3},{value:"Optimization 1: Flat Data Structure for Feature Lookup",id:"optimization-1-flat-data-structure-for-feature-lookup",level:3},{value:"Optimization 2: Loop Unrolling for Auto-Vectorization",id:"optimization-2-loop-unrolling-for-auto-vectorization",level:3},{value:"Optimization 3: Unsafe Bounds-Check Elimination",id:"optimization-3-unsafe-bounds-check-elimination",level:3},{value:"Optimization 4: Fused Operations",id:"optimization-4-fused-operations",level:3},{value:"Cumulative Optimization Impact",id:"cumulative-optimization-impact",level:3},{value:"Training Benchmark Results (200 iterations)",id:"training-benchmark-results-200-iterations",level:3},{value:"Accuracy Verification",id:"accuracy-verification",level:3},{value:"What Didn&#39;t Work",id:"what-didnt-work",level:2},{value:"Key Insight: Different Tasks, Different Bottlenecks",id:"key-insight-different-tasks-different-bottlenecks",level:2},{value:"Why python-crfsuite Was Initially Faster",id:"why-python-crfsuite-was-initially-faster",level:3},{value:"Lessons Learned",id:"lessons-learned",level:3},{value:"Migration Path",id:"migration-path",level:2},{value:"Model Compatibility",id:"model-compatibility",level:2},{value:"Conclusion",id:"conclusion",level:2},{value:"Try It Out",id:"try-it-out",level:2},{value:"Appendix",id:"appendix",level:2},{value:"Hyperparameters",id:"hyperparameters",level:3},{value:"Hardware",id:"hardware",level:3},{value:"Code References",id:"code-references",level:3},{value:"Detailed Benchmark Results (2026-01-31)",id:"detailed-benchmark-results-2026-01-31",level:3}];function h(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["In underthesea v9.2.5, we completed the migration from ",(0,t.jsx)(n.code,{children:"python-crfsuite"})," to our native Rust implementation ",(0,t.jsx)(n.code,{children:"underthesea-core"}),". This change resulted in a ",(0,t.jsx)(n.strong,{children:"20% performance improvement"})," across all CRF-based NLP tasks, plus up to ",(0,t.jsx)(n.strong,{children:"10x faster training"})," through systematic optimization."]}),"\n",(0,t.jsx)(n.h2,{id:"background",children:"Background"}),"\n",(0,t.jsx)(n.p,{children:"Underthesea uses Conditional Random Fields (CRF) for several core NLP tasks:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Word tokenization"}),"\n",(0,t.jsx)(n.li,{children:"POS tagging"}),"\n",(0,t.jsx)(n.li,{children:"Named Entity Recognition (NER)"}),"\n",(0,t.jsx)(n.li,{children:"Chunking"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Previously, we relied on ",(0,t.jsx)(n.code,{children:"python-crfsuite"}),", a Python wrapper for the CRFsuite C++ library. While functional, this introduced overhead from multiple language boundaries."]}),"\n",(0,t.jsx)(n.h2,{id:"the-architecture-change",children:"The Architecture Change"}),"\n",(0,t.jsx)(n.h3,{id:"before-v921",children:"Before (v9.2.1)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        Python                                \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502    Input     \u2502\u2500\u2500\u2500\u25b6\u2502 CRFFeaturizer\u2502\u2500\u2500\u2500\u25b6\u2502   Python     \u2502  \u2502\n\u2502  \u2502   Tokens     \u2502    \u2502    (Rust)    \u2502    \u2502    List      \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                                                  \u2502          \u2502\n\u2502                                                  \u25bc          \u2502\n\u2502                                          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502                                          \u2502  pycrfsuite  \u2502  \u2502\n\u2502                                          \u2502    (C++)     \u2502  \u2502\n\u2502                                          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,t.jsx)(n.p,{children:"The data flow crossed multiple language boundaries:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Python \u2192 Rust (CRFFeaturizer)"}),"\n",(0,t.jsx)(n.li,{children:"Rust \u2192 Python (feature list)"}),"\n",(0,t.jsx)(n.li,{children:"Python \u2192 C++ (pycrfsuite)"}),"\n",(0,t.jsx)(n.li,{children:"C++ \u2192 Python (tags)"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"after-v925",children:"After (v9.2.5)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        Python                                \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502    Input     \u2502\u2500\u2500\u2500\u25b6\u2502 CRFFeaturizer\u2502\u2500\u2500\u2500\u25b6\u2502  CRFTagger   \u2502  \u2502\n\u2502  \u2502   Tokens     \u2502    \u2502    (Rust)    \u2502    \u2502    (Rust)    \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                              \u2502                   \u2502          \u2502\n\u2502                              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2502\n\u2502                               underthesea-core              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,t.jsx)(n.p,{children:"Now both preprocessing and inference are in Rust within the same module, eliminating the C++ dependency entirely."}),"\n",(0,t.jsx)(n.h2,{id:"code-changes",children:"Code Changes"}),"\n",(0,t.jsx)(n.p,{children:"The change was minimal from the API perspective:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Before:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import pycrfsuite\nfrom underthesea_core import CRFFeaturizer\n\nclass FastCRFSequenceTagger:\n    def load(self, base_path):\n        estimator = pycrfsuite.Tagger()\n        estimator.open(model_path)\n        # ...\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"After:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from underthesea_core import CRFFeaturizer, CRFTagger\n\nclass FastCRFSequenceTagger:\n    def load(self, base_path):\n        estimator = CRFTagger()\n        estimator.load(model_path)\n        # ...\n"})}),"\n",(0,t.jsx)(n.h2,{id:"inference-benchmark-results",children:"Inference Benchmark Results"}),"\n",(0,t.jsx)(n.p,{children:"We benchmarked both versions on the same hardware (AMD EPYC 7713, Linux, Python 3.12) with 100 iterations:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Function"}),(0,t.jsx)(n.th,{children:"v9.2.1 (pycrfsuite)"}),(0,t.jsx)(n.th,{children:"v9.2.5 (Rust)"}),(0,t.jsx)(n.th,{children:"Improvement"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"word_tokenize"}),(0,t.jsx)(n.td,{children:"1.45ms"}),(0,t.jsx)(n.td,{children:"1.18ms"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"-19%"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"pos_tag"}),(0,t.jsx)(n.td,{children:"3.58ms"}),(0,t.jsx)(n.td,{children:"2.93ms"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"-18%"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"ner"}),(0,t.jsx)(n.td,{children:"9.61ms"}),(0,t.jsx)(n.td,{children:"8.49ms"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"-12%"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"chunk"}),(0,t.jsx)(n.td,{children:"6.19ms"}),(0,t.jsx)(n.td,{children:"5.65ms"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"-9%"})})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"why-is-inference-faster",children:"Why Is Inference Faster?"}),"\n",(0,t.jsx)(n.h3,{id:"1-unified-runtime",children:"1. Unified Runtime"}),"\n",(0,t.jsxs)(n.p,{children:["Both ",(0,t.jsx)(n.code,{children:"CRFFeaturizer"})," and ",(0,t.jsx)(n.code,{children:"CRFTagger"})," are now in the same Rust module. This allows:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Shared memory management"}),"\n",(0,t.jsx)(n.li,{children:"No intermediate Python object creation"}),"\n",(0,t.jsx)(n.li,{children:"Potential for future optimizations (e.g., fusing operations)"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"2-optimized-viterbi-implementation",children:"2. Optimized Viterbi Implementation"}),"\n",(0,t.jsx)(n.p,{children:"Our Rust implementation uses pre-allocated vectors and cache-friendly memory layouts:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"fn viterbi(&self, attr_ids: &[Vec<u32>]) -> TaggingResult {\n    let n = attr_ids.len();\n    let num_labels = self.model.num_labels;\n\n    // Pre-allocated score matrix\n    let mut score = vec![vec![f64::NEG_INFINITY; num_labels]; n];\n    let mut back = vec![vec![0u32; num_labels]; n];\n\n    // Cache emission scores per position\n    let emission_t = self.model.emission_scores(&attr_ids[t]);\n\n    // Direct memory access in inner loop\n    for y in 0..num_labels {\n        for y_prev in 0..num_labels {\n            let trans = self.model.get_transition(y_prev as u32, y as u32);\n            // ...\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-zero-copy-where-possible",children:"3. Zero-Copy Where Possible"}),"\n",(0,t.jsx)(n.p,{children:"PyO3 bindings allow efficient data transfer between Python and Rust without unnecessary copying."}),"\n",(0,t.jsx)(n.h3,{id:"4-removed-dependency",children:"4. Removed Dependency"}),"\n",(0,t.jsxs)(n.p,{children:["Removing ",(0,t.jsx)(n.code,{children:"python-crfsuite"})," also means:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Simpler installation (no C++ compiler needed)"}),"\n",(0,t.jsx)(n.li,{children:"Smaller package size"}),"\n",(0,t.jsx)(n.li,{children:"Fewer potential compatibility issues"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"training-optimizations",children:"Training Optimizations"}),"\n",(0,t.jsxs)(n.p,{children:["Beyond inference, we also optimized the CRF trainer in ",(0,t.jsx)(n.code,{children:"underthesea-core"}),". The original Rust trainer was ",(0,t.jsx)(n.strong,{children:"7.2x slower"})," than python-crfsuite for word segmentation. Through four key optimizations, we made it competitive \u2014 and even faster for some tasks."]}),"\n",(0,t.jsx)(n.h3,{id:"crf-training-algorithm",children:"CRF Training Algorithm"}),"\n",(0,t.jsx)(n.p,{children:"The trainer uses Limited-memory BFGS (L-BFGS) optimization with Orthant-Wise Limited-memory Quasi-Newton (OWL-QN) extension for L1 regularization:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"minimize: L(w) = -log P(y|x) + \u03bb\u2081\u2016w\u2016\u2081 + \u03bb\u2082\u2016w\u2016\u2082\xb2\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Where ",(0,t.jsx)(n.code,{children:"\u03bb\u2081 = 1.0"})," (L1 coefficient) and ",(0,t.jsx)(n.code,{children:"\u03bb\u2082 = 0.001"})," (L2 coefficient)."]}),"\n",(0,t.jsx)(n.p,{children:"The core computation is the forward-backward algorithm for computing:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Partition function"})," Z(x) via forward pass"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Marginal probabilities"})," P(y_t | x) via forward-backward"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Gradient"})," \u2207L(w) = E_model[f] - E_empirical[f]"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Complexity per sequence: ",(0,t.jsx)(n.strong,{children:"O(n \xd7 L\xb2)"})," where n is the sequence length and L is the number of labels."]}),"\n",(0,t.jsxs)(n.p,{children:["Following CRFsuite's approach, we use ",(0,t.jsx)(n.strong,{children:"scaled probability space"})," instead of log-space:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"// Instead of: log_alpha[t][y] = logsumexp(log_alpha[t-1] + log_trans + log_state)\n// We use:     alpha[t][y] = sum(alpha[t-1] * exp_trans) * exp_state * scale\n"})}),"\n",(0,t.jsx)(n.p,{children:"Benefits:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"No log/exp in inner loops"}),"\n",(0,t.jsx)(n.li,{children:"Better numerical stability with scaling factors"}),"\n",(0,t.jsx)(n.li,{children:"Matches CRFsuite's performance characteristics"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"starting-point",children:"Starting Point"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Task"}),(0,t.jsx)(n.th,{children:"python-crfsuite"}),(0,t.jsx)(n.th,{children:"underthesea-core (original)"}),(0,t.jsx)(n.th,{children:"Slowdown"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Word Segmentation"}),(0,t.jsx)(n.td,{children:"2m 34s"}),(0,t.jsx)(n.td,{children:"18m 33s"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"7.2x slower"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"POS Tagging"}),(0,t.jsx)(n.td,{children:"4m 50s"}),(0,t.jsx)(n.td,{children:"7m 21s"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"1.5x slower"})})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"optimization-1-flat-data-structure-for-feature-lookup",children:"Optimization 1: Flat Data Structure for Feature Lookup"}),"\n",(0,t.jsxs)(n.p,{children:["The original used nested vectors (",(0,t.jsx)(n.code,{children:"Vec<Vec<(u32, u32)>>"}),") for feature lookup \u2014 each inner ",(0,t.jsx)(n.code,{children:"Vec"})," separately heap-allocated, causing cache misses for large feature sets (562k features)."]}),"\n",(0,t.jsx)(n.p,{children:"We flattened into contiguous arrays with offset indexing:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"// Contiguous memory, excellent cache locality\nattr_offsets: Vec<u32>               // attr_id -> start index\nattr_features_flat: Vec<(u32, u32)>  // flattened (label_id, feature_id) pairs\n\n// Lookup: O(1) with sequential memory access\nlet start = attr_offsets[attr_id];\nlet end = attr_offsets[attr_id + 1];\nfor i in start..end {\n    let (label_id, feature_id) = attr_features_flat[i];\n    // Process feature...\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Result"}),":"]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Task"}),(0,t.jsx)(n.th,{children:"Before"}),(0,t.jsx)(n.th,{children:"After"}),(0,t.jsx)(n.th,{children:"Speedup"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Word Segmentation"}),(0,t.jsx)(n.td,{children:"18m 33s"}),(0,t.jsx)(n.td,{children:"1m 49s"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"10.2x"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"POS Tagging"}),(0,t.jsx)(n.td,{children:"7m 21s"}),(0,t.jsx)(n.td,{children:"5m 9s"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"1.4x"})})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"The larger speedup for word segmentation (562k features vs 37k for POS) confirms the feature lookup was the bottleneck."}),"\n",(0,t.jsx)(n.h3,{id:"optimization-2-loop-unrolling-for-auto-vectorization",children:"Optimization 2: Loop Unrolling for Auto-Vectorization"}),"\n",(0,t.jsx)(n.p,{children:"The forward-backward algorithm has O(n \xd7 L\xb2) inner loops. For POS tagging (16 labels = 256 transitions per timestep), we applied 4-way manual loop unrolling to enable SIMD auto-vectorization:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"// 4-way unrolled for instruction-level parallelism\nlet chunks = num_labels / 4;\nfor i in 0..chunks {\n    let y = i * 4;\n    let a0 = alpha[curr + y];\n    let a1 = alpha[curr + y + 1];\n    let a2 = alpha[curr + y + 2];\n    let a3 = alpha[curr + y + 3];\n\n    let t0 = trans[trans_base + y];\n    let t1 = trans[trans_base + y + 1];\n    let t2 = trans[trans_base + y + 2];\n    let t3 = trans[trans_base + y + 3];\n\n    alpha[curr + y]     = a0 + alpha_prev * t0;\n    alpha[curr + y + 1] = a1 + alpha_prev * t1;\n    alpha[curr + y + 2] = a2 + alpha_prev * t2;\n    alpha[curr + y + 3] = a3 + alpha_prev * t3;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Result"}),": POS tagging (10 iterations) went from 25.7s to 17.58s \u2014 a ",(0,t.jsx)(n.strong,{children:"1.46x speedup"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"optimization-3-unsafe-bounds-check-elimination",children:"Optimization 3: Unsafe Bounds-Check Elimination"}),"\n",(0,t.jsxs)(n.p,{children:["We used ",(0,t.jsx)(n.code,{children:"unsafe"})," with ",(0,t.jsx)(n.code,{children:"get_unchecked"})," for hot paths where indices are provably valid, eliminating Rust's bounds checks in tight loops:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"// Safe but slow: 2 bounds checks per iteration\nfor y in 0..num_labels {\n    gradient[feature_id] += state_mexp[base + y];\n}\n\n// Unsafe but fast: 0 bounds checks\nunsafe {\n    for y in 0..num_labels {\n        *gradient.get_unchecked_mut(feature_id) +=\n            *state_mexp.get_unchecked(base + y);\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["All ",(0,t.jsx)(n.code,{children:"unsafe"})," blocks are guarded by loop bounds derived from array lengths, assertions, and algorithm invariants."]}),"\n",(0,t.jsx)(n.h3,{id:"optimization-4-fused-operations",children:"Optimization 4: Fused Operations"}),"\n",(0,t.jsx)(n.p,{children:"Separate loops for related operations cause redundant memory traversals. We fused them:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"// Before: 3 separate loops, 3 memory traversals\nfor y in 0..L { alpha[y] *= exp_state[y]; }\nfor y in 0..L { sum += alpha[y]; }\nfor y in 0..L { alpha[y] *= scale; }\n\n// After: 1 fused loop + 1 normalization pass\nlet mut sum = 0.0;\nfor y in 0..L {\n    let val = alpha[y] * exp_state[y];\n    alpha[y] = val;\n    sum += val;\n}\nlet scale = 1.0 / sum;\nfor y in 0..L { alpha[y] *= scale; }\n"})}),"\n",(0,t.jsx)(n.h3,{id:"cumulative-optimization-impact",children:"Cumulative Optimization Impact"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Optimization"}),(0,t.jsx)(n.th,{children:"Word Seg Speedup"}),(0,t.jsx)(n.th,{children:"POS Tag Speedup"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Baseline (original)"}),(0,t.jsx)(n.td,{children:"1.0x"}),(0,t.jsx)(n.td,{children:"1.0x"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"+ Flat data structure"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"10.2x"})}),(0,t.jsx)(n.td,{children:"1.4x"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"+ Loop unrolling"}),(0,t.jsx)(n.td,{children:"10.2x"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"2.1x"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"+ Unsafe bounds elim"}),(0,t.jsx)(n.td,{children:"~10.2x"}),(0,t.jsx)(n.td,{children:"~2.3x"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Total"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"10.2x"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"2.3x"})})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"training-benchmark-results-200-iterations",children:"Training Benchmark Results (200 iterations)"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Task"}),(0,t.jsx)(n.th,{children:"Features"}),(0,t.jsx)(n.th,{children:"Labels"}),(0,t.jsx)(n.th,{children:"python-crfsuite"}),(0,t.jsx)(n.th,{children:"underthesea-core"}),(0,t.jsx)(n.th,{children:"Result"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Word Segmentation"}),(0,t.jsx)(n.td,{children:"562,885"}),(0,t.jsx)(n.td,{children:"2"}),(0,t.jsx)(n.td,{children:"2m 2s"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"1m 38s"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"1.24x faster"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"POS Tagging"}),(0,t.jsx)(n.td,{children:"626,723"}),(0,t.jsx)(n.td,{children:"16"}),(0,t.jsx)(n.td,{children:"4m 3s"}),(0,t.jsx)(n.td,{children:"4m 14s"}),(0,t.jsx)(n.td,{children:"~equal (4% slower)"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"accuracy-verification",children:"Accuracy Verification"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Task"}),(0,t.jsx)(n.th,{children:"Metric"}),(0,t.jsx)(n.th,{children:"python-crfsuite"}),(0,t.jsx)(n.th,{children:"underthesea-core"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Word Segmentation"}),(0,t.jsx)(n.td,{children:"Syllable Accuracy"}),(0,t.jsx)(n.td,{children:"98.89%"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"98.89%"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Word Segmentation"}),(0,t.jsx)(n.td,{children:"Word F1"}),(0,t.jsx)(n.td,{children:"98.00%"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"98.00%"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"POS Tagging"}),(0,t.jsx)(n.td,{children:"Accuracy"}),(0,t.jsx)(n.td,{children:"95.98%"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"95.97%"})})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Accuracy is identical"})," \u2014 optimizations only affected performance, not correctness."]}),"\n",(0,t.jsx)(n.h2,{id:"what-didnt-work",children:"What Didn't Work"}),"\n",(0,t.jsx)(n.p,{children:"We evaluated several additional optimizations that did not provide significant improvements:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Explicit SIMD Intrinsics (AVX2)"}),": The inner loops process only 2-16 labels, too small for explicit SIMD to outperform the compiler's auto-vectorization with loop unrolling."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Parallel Forward-Backward (Rayon)"}),": Thread-local gradient accumulation overhead from buffer allocation per sequence and gradient merging negated the parallelism benefits. Sequential processing with buffer reuse remains faster."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Memory Pool for Temporary Buffers"}),": Already implemented \u2014 the current implementation reuses buffers across sequences within each L-BFGS evaluation. Further pooling across evaluations showed minimal improvement."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Compressed Sparse Features"}),": The flat data structure with offset indexing already provides efficient sparse feature access \u2014 additional compression just adds decode overhead."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"key-insight-different-tasks-different-bottlenecks",children:"Key Insight: Different Tasks, Different Bottlenecks"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Feature Set Size"}),(0,t.jsx)(n.th,{children:"Bottleneck"}),(0,t.jsx)(n.th,{children:"Best Optimization"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Large (500k+)"}),(0,t.jsx)(n.td,{children:"Feature lookup (cache misses)"}),(0,t.jsx)(n.td,{children:"Flat data structure"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Small (<50k)"}),(0,t.jsx)(n.td,{children:"Forward-backward O(L\xb2)"}),(0,t.jsx)(n.td,{children:"Loop unrolling"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"why-python-crfsuite-was-initially-faster",children:"Why python-crfsuite Was Initially Faster"}),"\n",(0,t.jsx)(n.p,{children:"CRFsuite (C implementation) already had:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Hand-optimized sparse feature storage"})," \u2014 similar to our flat structure"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"SIMD-vectorized matrix operations"})," \u2014 AVX/SSE intrinsics"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cache-optimized memory layout"})," \u2014 column-major for transitions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Decades of optimization"})," \u2014 mature codebase"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Our flat data structure and loop unrolling effectively replicated these advantages in Rust."}),"\n",(0,t.jsx)(n.h3,{id:"lessons-learned",children:"Lessons Learned"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Profile first"})," \u2014 the bottleneck was different for each task"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Data structure matters"})," \u2014 flat arrays beat nested vectors by 10x"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cache locality is critical"})," \u2014 sequential memory access enables hardware prefetching"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Unsafe Rust is justified"})," \u2014 when correctness is provable and performance is critical"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Incremental migration reduces risk"})," \u2014 migrating one task at a time allowed validation at each step"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"migration-path",children:"Migration Path"}),"\n",(0,t.jsx)(n.p,{children:"The migration was done incrementally across 4 releases:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Version"}),(0,t.jsx)(n.th,{children:"Changes"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"v9.2.2"}),(0,t.jsx)(n.td,{children:"word_tokenize migrated"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"v9.2.3"}),(0,t.jsx)(n.td,{children:"pos_tag, ner, chunking migrated"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"v9.2.4"}),(0,t.jsx)(n.td,{children:"CRFTrainer migrated, removed unused files"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"v9.2.5"}),(0,t.jsx)(n.td,{children:"Removed python-crfsuite dependency"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"model-compatibility",children:"Model Compatibility"}),"\n",(0,t.jsxs)(n.p,{children:["The Rust implementation can load existing ",(0,t.jsx)(n.code,{children:".crfsuite"})," model files trained by python-crfsuite. No retraining is required."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# Works with both old and new models\nfrom underthesea import word_tokenize\nword_tokenize(\"H\xe0 N\u1ed9i l\xe0 th\u1ee7 \u0111\xf4 c\u1ee7a Vi\u1ec7t Nam\")\n# ['H\xe0 N\u1ed9i', 'l\xe0', 'th\u1ee7 \u0111\xf4', 'c\u1ee7a', 'Vi\u1ec7t Nam']\n"})}),"\n",(0,t.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"By rewriting our CRF implementation in Rust and unifying the pipeline, we achieved:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"12-19% faster inference"})," across all CRF-based tasks"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"1.24x faster training"})," for word segmentation (10x from original Rust implementation)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Identical accuracy"})," \u2014 no degradation from the migration"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Simpler dependency tree"})," (no python-crfsuite / C++ compiler needed)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Better maintainability"})," with a single Rust codebase"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The full implementation is available in ",(0,t.jsx)(n.a,{href:"https://github.com/undertheseanlp/underthesea/tree/main/extensions/underthesea_core",children:"underthesea-core"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"try-it-out",children:"Try It Out"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"pip install underthesea==9.2.5\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from underthesea import word_tokenize, pos_tag, ner, chunk\n\nword_tokenize("Vi\u1ec7t Nam")  # 20% faster!\n'})}),"\n",(0,t.jsx)(n.h2,{id:"appendix",children:"Appendix"}),"\n",(0,t.jsx)(n.h3,{id:"hyperparameters",children:"Hyperparameters"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Parameter"}),(0,t.jsx)(n.th,{children:"Value"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"c1 (L1)"}),(0,t.jsx)(n.td,{children:"1.0"}),(0,t.jsx)(n.td,{children:"L1 regularization coefficient"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"c2 (L2)"}),(0,t.jsx)(n.td,{children:"0.001"}),(0,t.jsx)(n.td,{children:"L2 regularization coefficient"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"max_iterations"}),(0,t.jsx)(n.td,{children:"200"}),(0,t.jsx)(n.td,{children:"Maximum L-BFGS iterations"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"linesearch"}),(0,t.jsx)(n.td,{children:"Backtracking"}),(0,t.jsx)(n.td,{children:"Line search algorithm for OWL-QN"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"max_step_size"}),(0,t.jsx)(n.td,{children:"1e20"}),(0,t.jsx)(n.td,{children:"Allow large steps (critical for convergence)"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"hardware",children:"Hardware"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Component"}),(0,t.jsx)(n.th,{children:"Specification"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"CPU"}),(0,t.jsx)(n.td,{children:"AMD EPYC 7713 64-Core Processor"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Platform"}),(0,t.jsx)(n.td,{children:"Linux"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Rust"}),(0,t.jsx)(n.td,{children:"1.75+ (release mode with LTO)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Python"}),(0,t.jsx)(n.td,{children:"3.12"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"code-references",children:"Code References"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"File"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"underthesea_core/src/crf/trainer.rs"})}),(0,t.jsx)(n.td,{children:"Main CRF trainer implementation"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"underthesea_core/src/crf/model.rs"})}),(0,t.jsx)(n.td,{children:"CRF model structure"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"tre-1/scripts/train.py"})}),(0,t.jsx)(n.td,{children:"POS tagger training script"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"tre-1/scripts/train_word_segmentation.py"})}),(0,t.jsx)(n.td,{children:"Word segmentation training script"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"detailed-benchmark-results-2026-01-31",children:"Detailed Benchmark Results (2026-01-31)"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"10-Iteration Tests:"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Task"}),(0,t.jsx)(n.th,{children:"Trainer"}),(0,t.jsx)(n.th,{children:"Training Time"}),(0,t.jsx)(n.th,{children:"Accuracy"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"POS Tagging"}),(0,t.jsx)(n.td,{children:"python-crfsuite"}),(0,t.jsx)(n.td,{children:"12.96s"}),(0,t.jsx)(n.td,{children:"78.37%"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"POS Tagging"}),(0,t.jsx)(n.td,{children:"underthesea-core"}),(0,t.jsx)(n.td,{children:"18.51s"}),(0,t.jsx)(n.td,{children:"75.42%"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Word Segmentation"}),(0,t.jsx)(n.td,{children:"python-crfsuite"}),(0,t.jsx)(n.td,{children:"6.78s"}),(0,t.jsx)(n.td,{children:"81.44% F1"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Word Segmentation"}),(0,t.jsx)(n.td,{children:"underthesea-core"}),(0,t.jsx)(n.td,{children:"11.99s"}),(0,t.jsx)(n.td,{children:"82.81% F1"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"200-Iteration Tests:"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Task"}),(0,t.jsx)(n.th,{children:"Trainer"}),(0,t.jsx)(n.th,{children:"Training Time"}),(0,t.jsx)(n.th,{children:"Accuracy"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"POS Tagging"}),(0,t.jsx)(n.td,{children:"python-crfsuite"}),(0,t.jsx)(n.td,{children:"243.22s"}),(0,t.jsx)(n.td,{children:"95.98%"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"POS Tagging"}),(0,t.jsx)(n.td,{children:"underthesea-core"}),(0,t.jsx)(n.td,{children:"254.07s"}),(0,t.jsx)(n.td,{children:"95.97%"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Word Segmentation"}),(0,t.jsx)(n.td,{children:"python-crfsuite"}),(0,t.jsx)(n.td,{children:"121.69s"}),(0,t.jsx)(n.td,{children:"98.89% / 98.00% F1"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Word Segmentation"}),(0,t.jsx)(n.td,{children:"underthesea-core"}),(0,t.jsx)(n.td,{children:"98.34s"}),(0,t.jsx)(n.td,{children:"98.89% / 98.00% F1"})]})]})]})]})}function o(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453(e,n,r){r.d(n,{R:()=>l,x:()=>d});var i=r(6540);const t={},s=i.createContext(t);function l(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(s.Provider,{value:n},e.children)}},2413(e){e.exports=JSON.parse('{"permalink":"/blog/rewrite-rust-crf-model","editUrl":"https://github.com/undertheseanlp/underthesea/tree/main/docusaurus/blog/2026-02-02-rewrite-rust-crf-model.md","source":"@site/blog/2026-02-02-rewrite-rust-crf-model.md","title":"Rewriting CRF Model in Rust","description":"In underthesea v9.2.5, we completed the migration from python-crfsuite to our native Rust implementation underthesea-core. This change resulted in a 20% performance improvement across all CRF-based NLP tasks, plus up to 10x faster training through systematic optimization.","date":"2026-02-02T00:00:00.000Z","tags":[{"inline":true,"label":"rust","permalink":"/blog/tags/rust"},{"inline":true,"label":"performance","permalink":"/blog/tags/performance"},{"inline":true,"label":"crf","permalink":"/blog/tags/crf"},{"inline":true,"label":"nlp","permalink":"/blog/tags/nlp"}],"readingTime":8.82,"hasTruncateMarker":true,"authors":[{"name":"Vu Anh","title":"Creator of Underthesea","url":"https://github.com/rain1024","imageURL":"https://github.com/rain1024.png","key":"rain1024","page":null}],"frontMatter":{"slug":"rewrite-rust-crf-model","title":"Rewriting CRF Model in Rust","authors":["rain1024"],"tags":["rust","performance","crf","nlp"]},"unlisted":false,"prevItem":{"title":"Rust-Powered Text Classification","permalink":"/blog/rust-text-classifier"}}')}}]);